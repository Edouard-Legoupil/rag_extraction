---
title: Generating and Improving Evaluation Report "**Brief**"
subtitle: Evaluating Retrieval-Augmented Generation with Large Language Model
date: today
author: Edouard Legoupil, UNHCR Evaluation Office
format: unhcr-html
jupyter: python3
toc: true
---

::: {.bg-primary .text-white .p-3 .column-page}
*"We are drowning in information, while starving for wisdom. The world henceforth will be run by synthesizers, people able to put together the right information at the right time, think critically about it, and make important choices wisely."* - E. O. Wilson
:::

## Abstract

Artificial Inteligence (AI) is presented as the potential trigger for the [fifth wave](https://www.nature.com/articles/s41599-019-0253-6) of the **evidence revolution** (*following the 4 previous ones: 1.Outcome Monitoring, 2.Impact Evaluation, 3.Systematic Reviews and 4.Knowledge Brokering*). This actually reflects a situation where considering the [numbers of published evaluation reports across the UN system](https://www.uneval.org/evaluation/reports), **information retrieval and evidence generalization** challenges have arisen: How to extract the most relevant findings and recommendations from within a specific context and to reuse and re-inject them in a different but appropriate context?

The key deliverable from an evaluation process is usually a long report (*often over 60 pages PDF file*). From this report, two-pagers executive "briefs" are usually designed for the consumption of the senior executive audience. Striking the balance between concise and informative can be tricky but what remains more challenging is the subjective dimensions involved in **choosing what to include and what to exclude**, especially in terms of highlighting critical aspects while deciding on what are the less relevant details to omit... The potential fear of being, like Cassandra, the bearer of bad news comes with the structural risk of "cushioning" the real evaluation findings to a point where they get hidden. Relying on automated retrieval can therefore help improving the objectivity of the summarization.

Retrieval-augmented generation (RAG) is a type of Artificial Inteligence (AI) question-answering framework that [surfaced in 2020](https://arxiv.org/pdf/2005.11401) and that synergizes the capabilities of Large Language Model (LLMs) and information retrieval systems, also called text mining. This paper is presenting the challenges and opportunities associated with those new approaches. It targets a technical audience that may consider including such techniques within their personal information management toolkit, and this working safely, fully offline on their own computer.

First, we explain how to create an initial [two-pagers evaluation brief](https://github.com/Edouard-Legoupil/rag_extraction/raw/main/generated/Evaluation_Brief_response_text_bert.docx) using an orchestration of models and functions. Rather than relying on ad-hoc user interactions through a black box chat interface, it is possible to set up documented and **reproducible** scripts that can directly output a word document. The same approach could actually be applied to other textual analysis needs, for instance: extracting causal chains from the transcriptions of Focus Group Discussions, generating potential theories of change from needs assessment reports or assessing sufficient usage of programmatic evidences when developing Operation Strategic Plan.

Second, we review the techniques that can be used to **evaluate** and optimize summarisation scripts to minimize the risk of AI hallucinations. We generate a [second alternative brief](https://github.com/Edouard-Legoupil/rag_extraction/raw/main/generated/Evaluation_Brief_response_mmr_recursivecharactertext_bge.docx), and then create an evaluation dataset to explore the different metrics that can be used to evaluate information retrieval process.

Last we discuss how such approach can actually inform decisions and strategies on future AI **deployment** approaches: i.e. what needs to be set up to create training dataset that would allow to fine-tune models and further increase the performance of evidence retrieval and re-injection.

## Introduction

Building a robust information retrieval system requires to configure different components:

1)  **Retrieval**: Build a knowledge base and configure how to retrieve the information from it;

2)  **Generation**: Define efficient prompt to query the system;

3)  **Evaluation**: Explore and combine various options for both Retrieval and Generation to compare the results.

4)  **Deployment**: Organise AI-ready feedback and prepare data for fine-tuning.

This paper compiles the results of experimentation applied to a practical use case. It includes a *cookbook* with a reproducible recipes so that colleagues can rerun and learn from it. It also contains broader considerations on the usage of AI for public programme evaluations, especially in the last part around deployment. We used here the [2019 Evaluation of UNHCR’s data use and information management approaches](https://www.unhcr.org/sites/default/files/legacy-pdf/5dd4f7d24.pdf) to illustrate the process. We hope that eaders will be able to adjust this tutorial to their own use cases! Script below re based on [langChain](https://python.langchain.com/v0.1/docs/use_cases/question_answering/) python library but the same pipeline could also be built with the other main LLM orchestration library called [LlamaIndex](https://docs.llamaindex.ai/en/stable/use_cases/q_and_a/)

The illustration from [HuggingFace RAG Evaluation](https://huggingface.co/learn/cookbook/en/rag_evaluation) below nicely visualize the first two elements of the system architecture: retrieval (that includes: chunking, embedding, storing and retrieving) and generation (that includes prompting an LLM).

![RAG Evaluation, https://huggingface.co/learn/cookbook/en/rag_evaluation](RAG_workflow.png){fig-align="center"}

## Environment Set up

Make sure to install the last version of python and create a dedicated python environment to have a fresh install where to manage correctly all the dependencies between packages. This can be done with [conda](https://docs.conda.io/en/latest/) python modules management utility.

First directly in your OS Shell, create a new environment - here called **`evalenv`**

> conda create --name evalenv python=3.11

Then activate it! Et voila!

> conda activate evalenv

Once this environment selected as a kernel to run the notebook, we can install the required python libraries for RAG:

```{python}
## Library to load the PDF
%pip install --upgrade --quiet install pypdf

## Library for chunking
%pip install --upgrade --quiet  tiktoken
%pip install --upgrade --quiet nltk

## Library for the embedding
%pip install --upgrade --quiet  gpt4all
%pip install --upgrade --quiet  sentence-transformers

## Library to store the embeddng in a vector DB
%pip install --upgrade --quiet  chromadb

## Library for the LLM interaction
%pip install --upgrade --quiet install langchain
%pip install --upgrade --quiet langchain-community

## Library to save the results in a word document
%pip install --upgrade --quiet python-docx 

## Library to evaluat the RAG process
%pip install --upgrade --quiet ragas  
```

```{python}
# then Restart the jupyter kernel for this notebook
%reset -f
```

## Information Retrieval

### Load the PDF

There plenty of potential python packages to load pdf files... More details [here](https://python.langchain.com/docs/modules/data_connection/document_loaders/pdf). Note that more loader also exist for other type of data!!!

```{python}
from langchain_community.document_loaders import PyPDFLoader
loader = PyPDFLoader("files/Info_Mngt_eval_2019.pdf")
docs = loader.load_and_split()
```

### Chunking

If you have a large document, because of memory management, you will not be able to process it in one chunk. LangChain offers several built-in text splitters to **divide text into smaller chunks** based on different criteria.

Example of options that can be tested are:

-   Simple character-level processing with `CharacterTextSplitter,`

-   Recursive Splitting with `RecursiveCharacterTextSplitter`,

-   Words or semantic units with `TokenTextSplitter`,

-   Context-aware splitting with `NLTKTextSplitter` .

See example to understand how chunking works, see this online [viz](https://huggingface.co/spaces/m-ric/chunk_visualizer).

```{python}
from langchain.text_splitter import CharacterTextSplitter
splitter_text = CharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
chunks_text = splitter_text.split_documents(docs)
```

```{python}
from langchain.text_splitter import RecursiveCharacterTextSplitter 
splitter_recursivecharactertext = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
chunks_recursivecharactertext = splitter_recursivecharactertext.split_documents(docs)
```

```{python}
from langchain.text_splitter import TokenTextSplitter
splitter_tokentext = TokenTextSplitter(chunk_size=1000, chunk_overlap=200)
chunks_tokentext = splitter_tokentext.split_documents(docs)
```

```{python}
from langchain_text_splitters import NLTKTextSplitter
splitter_nltktext = NLTKTextSplitter(chunk_size=1000)
chunks_nltktext = splitter_nltktext.split_documents(docs)
```

### Instantiate a Vector Database

A [vector database](https://python.langchain.com/docs/modules/data_connection/vectorstores/) is a database that allows to efficiently store and query embeddings. Embedding are actually a **numeric representation of text data**. This conversion from text to numeric is used to represent words, sentences, or even entire documents in a compact and meaningful way. It captures the essence of a word’s meaning, context, and relationships with other words.

Vector databases extend the capabilities of traditional relational databases to embedding. However, the key distinguishing feature of a vector database is that query results aren’t an exact match to the query. Instead, using a specified **similarity metric**, the vector database returns data that are similar to a query.

There are here again numerous options in terms of Open Source vector DB that can be used - for instance: [ChromaDB](https://www.trychroma.com/), [Qdrant](https://qdrant.tech/), [Milvus](https://milvus.io/) or [FAISS](https://engineering.fb.com/2017/03/29/data-infrastructure/faiss-a-library-for-efficient-similarity-search/). Here we will just use Chroma.

```{python}
from langchain_community.vectorstores import Chroma
import chromadb 
chroma_client = chromadb.PersistentClient(path="persist/")
## A collection is created with the following
#chroma_collection = chroma_client.create_collection('collection')
```

### Generate Embedding

To generate embedding, we need a dedicated model and there's no single "best" option. Words with similar contexts tend to have closer vector representations. Some static word embeddings models are good capturing basic semantic relationships and are computationally efficient and fast but might not capture complex semantics or context-dependent meanings. Contextual Embeddings models have been developped to capture word meaning based on context, considering surrounding words in a sentence and handling ambiguity. But Training and usage can be computationally expensive, model sizes can be large.

LangChain often integrates with libraries like [Hugging Face Transformers](https://huggingface.co/sentence-transformers) for embedding usage. Best is to experiment with different embeddings to see what works best for a specific use case and dataset. There are plenty of options also depending on the languages.

Here we start with testing with [GPT4ALL](https://python.langchain.com/v0.1/docs/integrations/text_embedding/gpt4all/)

```{python}
from langchain_community.embeddings import GPT4AllEmbeddings 
embeddings_bert = GPT4AllEmbeddings()
```

Now we can store the embeddings and associated metadata in the `chroma vector` database using a specific collection name. Below we create distinct stores for each chunking options.

```{python}
vectorstore_text_bert = Chroma.from_documents(
    documents=chunks_text, 
    embedding=embeddings_bert, 
    collection_name= "text_bert",
    persist_directory = "persist")
vectorstore_text_bert.persist()
```

```{python}
vectorstore_recursivecharactertext_bert = Chroma.from_documents(
    documents=chunks_recursivecharactertext,
    embedding=embeddings_bert,
    collection_name= "recursivecharactertext_bert",
    persist_directory = "persist")
vectorstore_recursivecharactertext_bert.persist()
```

```{python}
vectorstore_tokentext_bert = Chroma.from_documents(
    documents=chunks_tokentext, 
    embedding=embeddings_bert, 
    collection_name= "tokentext_bert",
    persist_directory = "persist")
vectorstore_tokentext_bert.persist()
```

```{python}
vectorstore_nltktext_bert = Chroma.from_documents(
    documents=chunks_nltktext, 
    embedding=embeddings_bert, 
    collection_name= "nltktext_bert",
    persist_directory = "persist")
vectorstore_nltktext_bert.persist()
```

### Get from persistent storage

Chroma can run in various modes. Here we used the `persist` mode that allows to save to disk and load later. We can then re-open a previous database using its folder path:

```{python}
import chromadb
client = chromadb.PersistentClient(path="persist/")
```

Then we can get the name of collection available within that database

```{python}
collections = client.list_collections()
print(collections)
```

and get a previously saved vector collection

```{python}
vectorstore2_text_bert = Chroma(collection_name="text_bert",
                                persist_directory="persist/", 
                                embedding_function=embeddings_bert)
 
```

## Content Generation

### Set up a local LLM

If do not have access to a LLM API, an alternative is to install a local one and there are again plenty of Foundation LLM options to select from. Foundation models are AI neural networks trained on massive amounts of raw data (usually with unsupervised learning) that can be adapted to a wide variety of tasks.

::: callout-note
Open-source Large Language Models (LLM) have multiple advantages:

-   **Transparency and Flexibility**: accessible to the public, allowing developers to inspect, modify, and distribute the code. This transparency fosters a community-driven development process, leading to rapid innovation and diverse applications.

-   **Cost Savings**: generally more affordable in the long run as they don’t involve licensing fees, once infrastructure is setup and/or can be used offline on local computer.

-   **Added Features and Community Contributions**: can leverage multiple providers and internal teams for updates and support, which enables to stay at the forefront of technology and exercise greater control over their usage.

-   **Customizability**: allow for added features and benefit from community contributions. They are ideal for projects that require customization and those where budget constraints are a primary concern.

-   **Data Protection**: allow to use within the data enclave of your own computer without any data being sent to a remote server.
:::

There are multiple options to do that. An easy one is to install [OLLAMA](https://ollama.com/), which offers a wide [variety of open models](https://ollama.com/library) from the "AI Race" competitors [arena](https://chat.lmsys.org/): [LLama3](https://ollama.com/library/llama3) from Facebook, [gemma](https://ollama.com/library/gemma) from Google, [phi3](https://ollama.com/library/phi3) Microsoft but also [qwen](https://ollama.com/library/qwen) from the Chinese AliBaba, [falcon](https://ollama.com/library/falcon) from the Emirati Technology Innovation Institute, or [Mixtral](https://ollama.com/library/mixtral) from the french startup Mistral_AI. Langchain as dedicated [module to work with ollama](https://python.langchain.com/docs/integrations/chat/ollama).

Below, we start with [Mixtral Sparse Mixture-of-Expert](https://mistral.ai/news/mixtral-of-experts/), and specifically the quantized version: [8x7b-instruct-v0.1-q4_K_M](https://huggingface.co/TheBloke/Mixtral-8x7B-Instruct-v0.1-GGUF#explanation-of-quantisation-methods), an open-weight model designed to optimize performance-to-cost ratio, aka small in size to run on a strong laptop but good in performance. This download a file with the model which size around 26Gb.

```{python}
from langchain_community.chat_models import ChatOllama
llm_ollama = ChatOllama(
    model="mixtral:8x7b-instruct-v0.1-q4_K_M",  
    temperature=0.2, 
    request_timeout=500
)
```

The temperature is setting the *creativeness* of the response - the higher the more creative - below we will remain conservative! It is the equivalent of the *conversation style* setting in copilot: *creative \[1-0.7\], balanced \]0.7-0.4\], precise \]0.4,0\]*...

### Summarisation Prompt

A prompt is is a piece of text or a set of instructions, used by the LLM to generate a response or perform a task. Writing a good summarization prompt involves a few key steps:

-   Be **Specific**: Clearly state what you want to summarize. For example, “Summarize this Operation Strategic Plan in 200 words using abstractive summarization” or "Provide a summary of this needs assessment report, highlighting its key takeaways".

-   Define the **Scope**: Specify the length or depth of the summary you need. For instance, “Summarize this text into two paragraphs with simple language to make it easier to understand” or "Create a summary of this report by summarizing all chapters separately and then generating an overall summary of the report".

-   Set the **Context**: If the summary is for a specific purpose or audience, mention it in the prompt. For example, “I need to write talking points based on this report. Help me summarize this text for better understanding so that I can use it as an introduction emai” or "Summarize this for me like I’m 8 years old".

-   Use **Clear and Concise** Language: Avoid unnecessary complexity or ambiguity. A good prompt should provide enough direction to start but leave room for creativity.

Here we will try to create a prompt that generate an "Evaluation Brief" from the larger evaluation report.

Mixtral comes with specific tags to use for the prompt:

`<s>\[INST\] Instruction \[/INST\] Model answer</s>\[INST\] Follow-up instruction \[/INST\]`

```{python}
RAG_prompt = """
<s> 

[INST]Act if you were a public program evaluation specialist. 
Your audience target is composed of Senior Executives that are managing the operation or program that got evaluated.[/INST]

Your task is to generate an executive summary of the report you just ingested. </s>

[INST]
The summary should follow the following defined structure:
 
 - In the first part titled "What have we learn?", start with a description of the Forcibly Displaced population in the operation and include as 5 bullet points, the main challenges in relation with the evaluation objectives that have been identified in the document. 
 For each challenge explain why it's a problem and give a practical example to illustrate the consequence of this problem.
 
 - In a second part titled: "How did we get there?" try to review the common root causes for all the challenges that have been identified.  
 
 - In a third part, title: "What is working well?", provide a summary of the main success and achievement, i.e. things that have been identified as good practices and / or effective by the evaluators.
 
 - In the fourth part: "Now What to do?", include and summarize the recommendations proposed by the evaluation. Classify the recommendations according to their relevant level:
      
      1. "Operational Level": i.e recommendations that need to be implemented in the field as an adaptation or change of current practices. Please flag clearly, if this is the case, the recommendations related to practice that should be stopped or discontinued;
       
      2. "Organizational level": i.e recommendations that require changes in staffing or capacity building. Please flag clearly, if this is the case, the recommendations related to practice that should be stopped or discontinued;
    
      3. "Strategic Level": i.e recommendations that require a change in existing policy and rules.
 
 - At the end, for the "Conclusion", craft a reflective conclusion in one sentence that highlights the broader significance of the discussed topic. 
[/INST]
"""
```

### Set up the Retriever

A [retriever](https://python.langchain.com/docs/modules/data_connection/retrievers/) acts as an information gatekeeper in the RAG architecture. Its primary function is to search through a large corpus of data to find relevant pieces of information that can be used for text generation. You can think of it as a specialized librarian who knows exactly which ‘books’ to pull off the ‘shelves’ when you ask a question. In other words, the retriever first fetches relevant parts of the document pertaining to the user query, and then the Large Language Model (LLM) uses this information to generate a response.

The search_type argument within `vectorstore.as_retriever` for LangChain allows you to specify the retrieval strategy used to find relevant documents in your vector store. Different options are available:

1.  If you simply want the most relevant documents, "**similarity**" (default): This is the most common search type and is used by default. It performs a standard nearest neighbor search based on vector similarity. The retriever searches for documents in the vector store whose vector representations are closest to the query vector. Documents with higher similarity scores are considered more relevant and are returned first.

2.  If you need diverse results that cover different aspects of a topic, "**mmr**" (Maximum Marginal Relevance): This search type focuses on retrieving documents that are both relevant to the query and diverse from each other. It aims to avoid redundancy in the results. MMR is particularly useful when you want a collection of documents that cover different aspects of a topic, rather than just multiple copies of the most similar document.

3.  If you want to ensure a minimum level of relevance,"**similarity_score_threshold**": This search type retrieves documents based on a similarity score threshold. It only returns documents that have a similarity score above the specified threshold. This allows you to filter out documents with low relevance to the query.

The retriever also takes a series of potential parameters. The `search_kwargs={"k": 2,"score_threshold":0.8}` argument is a dictionary used to configure how documents are retrieved during the search process. This argument lets you control how many results you get (up to two in this case) and how good those results need to be (with a score of at least 0.8):

-   **k** (int): This parameter controls the number of documents to retrieve from the search. In this case, k: 2 specifies that the retriever should return up to two documents that match the search query.

-   **score_threshold** (float): This parameter sets a minimum score threshold for retrieved documents. Documents with a score lower than 0.8 will be excluded from the results. This essentially acts as a quality filter, ensuring a certain level of relevance between the query and retrieved documents.

The scoring mechanism used by the retriever might depend on the specific retriever implementation. It's likely based on how well the retrieved documents match the search query. The effectiveness of these parameters depends on your specific use case and the quality of the underlying retrieval system.

Even with "similarity", the retrieved documents might have varying degrees of relevance. Consider using ranking techniques within LangChain to further refine the results based on additional criteria. The underlying vector store might have limitations on the supported search types. Always refer to the documentation of your specific vector store to confirm available options.

We can build multiple retrievers out of the same `vectorstore`:

```{python}
ragRetriever_text_bert = vectorstore_text_bert.as_retriever()
```

```{python}
ragRetriever_recursivecharactertext_bert = vectorstore_recursivecharactertext_bert.as_retriever()
```

```{python}
ragRetriever_similarity_tokentext_bert = vectorstore_tokentext_bert.as_retriever(
            search_type="similarity_score_threshold",
            search_kwargs={
                "k": 3,
                "score_threshold": 0.4,
            },
)
```

```{python}
ragRetriever_similarity_nltktext_bert = vectorstore_nltktext_bert.as_retriever(
            search_type="similarity_score_threshold",
            search_kwargs={
                "k": 5,
                "score_threshold": 0.8,
            },
)
```

### Build the Chain

A retrieval question-answer chain act as a pipe: it takes an incoming question, look up relevant documents using a retriever, then pass those documents along with the original question into an LLM and return the answer the original question.

Note that from this stage, the following steps may take time to run - this will be highly dependent on the power of your computer - obviously the availability of GPUs - Graphical Processing Unit - will significantly increase the speed! FYI, this notebook was built on a Thinkpad P53 with a Quadro T1000 GPU.

```{python}
from langchain.chains import RetrievalQA
qa_chain = RetrievalQA.from_chain_type(
        llm=llm_ollama,
        retriever=ragRetriever_recursivecharactertext_bert, 
        chain_type="stuff",
        return_source_documents=True)

response_text_bert = qa_chain(RAG_prompt)
```

### Save in a word document

To complete the process, let's save the results within a a word document! This again can be automated

```{python}
import docx

# Create a document
doc = docx.Document()

# add a heading of level 0 (largest heading)
doc.add_heading('Evaluation Brief', 0) 

# Add another paragraph
p = doc.add_paragraph()

# Add a run with the summary and format it
run = p.add_run(response_text_bert["result"])
run.font.name = 'Arial'
run.font.size = docx.shared.Pt(12)

## Add  a disclaimer... ----------------
# add a page break to start a new page
doc.add_page_break()
# add a heading of level 2
doc.add_heading('DISCLAIMER:', 2)
doc_para = doc.add_paragraph() 
doc_para.add_run('This document contains material generated by artificial intelligence technology. While efforts have been made to ensure accuracy, please be aware that AI-generated content may not always fully represent the intent or expertise of human-authored material and may contain errors or inaccuracies. An AI model might generate content that sounds plausible but that is either factually incorrect or unrelated to the given context. These unexpected outcomes, also called AI hallucinations, can stem from biases, lack of real-world understanding, or limitations in training data.').italic = True

# Save the document ---------------
doc.save("generated/Evaluation_Brief_response_text_bert.docx")
```

## Process Evaluation

We were able to get a first brief... still how can we assess how good is this report?

### Build an alternate "Brief"

Let's try to generate a second report with different settings. Let's try first with a second embedding model... [Hugging face](https://huggingface.co/models?pipeline_tag=feature-extraction&sort=trending) has many options... and there is even a [leaderboard](https://huggingface.co/spaces/mteb/leaderboard) to see how they compete... We will select here the embedding model [bge-large-en-v1.5](https://huggingface.co/BAAI/bge-large-en-v1.5) from the Beijing Academy of Artificial Intelligence. It is small in size but efficient and it does not consume too much memory.

```{python}
from langchain_community.embeddings import HuggingFaceBgeEmbeddings

model_name = "BAAI/bge-small-en"
model_kwargs = {"device": "cpu"}
encode_kwargs = {"normalize_embeddings": True}
embeddings_bge= HuggingFaceBgeEmbeddings(
    model_name=model_name, model_kwargs=model_kwargs, encode_kwargs=encode_kwargs
)
```

We build the vector store using the new embedding...

```{python}
vectorstore_recursivecharactertext_bge = Chroma.from_documents(chunks_recursivecharactertext,
                                                   embeddings_bge,
                                               collection_name= "recursivecharactertext_bge",
                                               persist_directory = "persist")
```

...create our retriever now using Maximum Marginal Relevance...

```{python}
ragRetriever_mmr_recursivecharactertext_bge = vectorstore_recursivecharactertext_bge.as_retriever(
            search_type="mmr"
)
```

and let's use a different model for the LLM: [command-r)](https://cohere.com/blog/command-r), and specifically the quantized version: [command-r:35b-v0.1-q4_K_M](https://ollama.com/library/command-r:35b-v0.1-q4_K_M), an open-weight model designed to optimize RAG.

```{python}
from langchain_community.chat_models import ChatOllama
llm_ollama2 = ChatOllama(
    model="command-r:35b-v0.1-q4_K_M",  
    temperature=0.2, 
    request_timeout=500
)
```

... and then get our summary with the second LLM!

```{python}
from langchain.chains import RetrievalQA
qa_chain = RetrievalQA.from_chain_type(
        llm=llm_ollama2,
        retriever=ragRetriever_mmr_recursivecharactertext_bge, 
        chain_type="stuff",
        return_source_documents=True)

response_mmr_recursivecharactertext_bge = qa_chain(RAG_prompt)
```

Now saving it in a word document!

```{python}
import docx

# Create a document
doc = docx.Document()

# add a heading of level 0 (largest heading)
doc.add_heading('Evaluation Brief', 0) 

# Add another paragraph
p = doc.add_paragraph()

# Add a run with the summary and format it
run = p.add_run(response_mmr_recursivecharactertext_bge["result"])
run.font.name = 'Arial'
run.font.size = docx.shared.Pt(12)


## Add  a disclaimer... ----------------
# add a page break to start a new page
doc.add_page_break()
# add a heading of level 2
doc.add_heading('DISCLAIMER:', 2)
doc_para = doc.add_paragraph() 
doc_para.add_run('This document contains material generated by artificial intelligence technology. While efforts have been made to ensure accuracy, please be aware that AI-generated content may not always fully represent the intent or expertise of human-authored material and may contain errors or inaccuracies. An AI model might generate content that sounds plausible but that is either factually incorrect or unrelated to the given context. These unexpected outcomes, also called AI hallucinations, can stem from biases, lack of real-world understanding, or limitations in training data.').italic = True

# Save the document ---------------
doc.save("generated/Evaluation_Brief_response_mmr_recursivecharactertext_bge.docx")
```

Et voila! When reading the two reports, we can see significant differences... which is OK as it would be if it was a human doing it.. Though, it is likely that one report is better than the other. Now let's **evaluate** the quality of the summarization to objectively find out about this!

### Building the evaluation dataset

To do the evaluation, first we need to build an large-enough evaluation dataset so that the evaluation is based on multiple output. One approach is to extract from the report both:

-   all **findings and evidence**, i.e. what can be learnt from the specific context of this evaluation study, what are the root causes for the finding in this context and what are the main risks and difficulties in this context.

-   all **recommendations**, flagging clearly if the recommendations relate to practices that should be either discontinued on one side or on the other side to practices that should be scaled up.

To provide more perspectives for the extraction, the report can be reviewed from the angle of each of the potential 26 different type of experts that may look at UNHCR programme:

-   **4 experts for Strategic Impact** Peer Review: i.e., finding or recommendations that require a change in existing policy and regulations in relation within the specific impact area:

    1.  Attaining favorable protection environments
    2.  Realizing rights in safe environments
    3.  Empowering communities and achieving gender equality
    4.  Securing durable solutions

-   **17 experts for Operational Outcome** Peer Review: i.e., finding or recommendations that require a change that needs to be implemented in the field as an adaptation or change of current activities in relation within the specific outcome area:

    1.  Access to territory registration and documentation
    2.  Status determination
    3.  Protection policy and law
    4.  Gender-based violence
    5.  Child protection
    6.  Safety and access to justice
    7.  Community engagement and women's empowerment
    8.  Well-being and basic needs
    9.  Sustainable housing and settlements
    10. Healthy lives
    11. Education
    12. Clean water sanitation and hygiene
    13. Self-reliance, Economic inclusion, and livelihoods
    14. Voluntary repatriation and sustainable reintegration
    15. Resettlement and complementary pathways
    16. Local integration and other local solutions

-   **5 experts on Organizational Enabler** Peer Review: i.e., finding or recommendations that require changes in management practices, technical approach, business processes, staffing allocation or capacity building in relation with:

    1.  Systems and processes
    2.  Operational support and supply chain
    3.  People and culture
    4.  External engagement and resource mobilization
    5.  Leadership and governance

```{python}
# create the QA chain
from langchain.chains import RetrievalQA
qa_chain = RetrievalQA.from_chain_type(
        llm=llm_ollama,
        retriever=ragRetriever_mmr_recursivecharactertext_bge, 
        return_source_documents=True)

# testing it out
question = "Provide a list of all organisational recommendations within the report"
#result = qa_chain({"query": question})
#result["result"]
```

### Metrics Measurement

Getting the RAG pipeline's performance to a satisfying state is not straightforward. [RAGAS (Retrieval Augmented Generation Assessment)](https://docs.ragas.io/en/stable/) is a framework for reference-free evaluation of RAG pipelines. *“Reference-free”* evaluation means that instead of having to rely on human-annotated ground truth labels in the evaluation dataset, RAGAs leverages LLMs under the hood to conduct the [evaluations](https://docs.ragas.io/en/stable/howtos/integrations/langchain.html).

::: callout-note
There are several criteria used to **evaluate RAG applications**:

1.  Context-based for the **Retriever**: :

-   [**Context recall**](https://docs.ragas.io/en/stable/concepts/metrics/context_recall.html): Measures whether the context contains the correct information, compared to a provided ground truth, in order to produce an answer.

-   [**Context Precision**](https://docs.ragas.io/en/stable/concepts/metrics/context_precision.html) (also called Grounding): Measures whether items present in the contexts are ranked higher or not.

2.  Output-based for the **Generator** (LLM):

-   [**Faithfulness**](https://docs.ragas.io/en/stable/concepts/metrics/faithfulness.html) (also called Correctness or Factuality): Measures whether the LLM outputs are based on the provided ground truth.

-   [**Answer relevancy**](https://docs.ragas.io/en/stable/concepts/metrics/answer_relevance.html): Measures how directly the answer addresses the question.
:::

We can use a [dedicated model](https://docs.ragas.io/en/stable/howtos/customisations/ragas_custom_model.html#) as a critic of the first one

```{python}
# from langchain_community.llms import VLLM

# critic_llm = VLLM(
#     model="explodinggradients/Ragas-critic-llm-Qwen1.5-GPTQ",
#     trust_remote_code=True,  # mandatory for hf models
#     max_new_tokens=512,
#     top_k=10,
#     top_p=0.95,
#     temperature=0.0,)


```

```{python}
# from ragas import evaluate
  
```

```{python}
# from ragas.metrics import context_precision, answer_relevancy, faithfulness
# from ragas import evaluate
 
# raga_result = evaluate(
#     dataset=result,
#     llm=critic_llm,
#     metrics=[context_precision, faithfulness, answer_relevancy],
# )
```

## AI Deployment

### Buy or Build?

As presented in [Gartner AI readiness framework](https://www.gartner.com/en/information-technology/topics/ai-readiness), there are potential graduated steps in terms of deployment: consume, embed, extend and build, and for each strategic decisions between outsourced/internalized are required.

[![From Gartner: https://www.gartner.com/en/information-technology/topics/ai-readiness](GL0vYd_WcAAqUDZ.png){fig-align="center"}](https://www.gartner.com/en/information-technology/topics/ai-readiness)

Using off-the-shelves solutions, such as Commercial Copilot, in a "consume or embed" mode comes with inherent limitations:

-   to incorporate organization specific Knowledge in a systematic way;
-   to continuously update the knowledge base with any latest content;
-   to prevent what is called "Hallucinations", in other words the risk of generating incorrect or misleading information, that would not be context-aware.

This paper actually presented a recipe to extend existing foundation model, using the first step: Data Retrival and Prompt engineering. We highlighted the importance of the configuration to ensure the **reliability of the system** and therefore the relevance of managing directly such process.

The next step, Fine Tuning comes first with the additional requirement to build AI ready and validated data.

### AI ready data & Human Review

Building common knowledge on "data retrieval scripts" could be the first achievable target. This would imply to tune a RAG extraction for each evaluation report and build an evaluation dataset for each of them.

Human Review is key to maintaining quality, minimizing the risk of hallucination and enforcing alignment. It can be performed both before and after fine-tuning. Human labelling is performed to verify that the response is relevant, generic or out-of-context. A platform like [labelStudioo](https://labelstud.io/) can be used to implement such human review. The “Context/Question/Response” shall be reviewed and assessed as “Relevant” / “Generic” / “Out-of-scope".

After the peer review is sent to observation, operation feedback on the review can also be collected and use at a later stage to further fine tune the model

### Fine-Tuning

Using the labeled dataset, generated from the prompt, and then labeled, the next step will be to select any Open "foundational” LLM from HuggingFace and fine tune it. In line with UN statement to promote open source in general and ["open artificial intelligence models"](https://www.un.org/techenvoy/content/digital-public-goods), the resulting fine-tuned model could also be published on [huggingface](https://huggingface.co/).

A fine tune model could help front-loading many more contexts that a simple foundation model:

-   **Situation** – The fine-tune model would be relevant and specific in relation with Operation profile, Area of focus between one of the strategic impact, operational outcome, or organizational topics

-   **Task** - The fine-tune model could be triggered at a specific stage of the operation management cycle for Peer Review Purpose – at any stage of the Plan/Get/Show.

-   **Activity** – Based on the combination of situation and task, the fine-tune model would help re-injecting previously found evidence and/or recalling recommendations

-   **Results** – The fine-tune model output would be systematically saved in order to be re-assessed by humans to fine-tune it further from this feedback and improve over time (also called reinforcement learning.)

## Conclusion

Leveraging the potential of AI for evaluation implies significant investement. Tuning RAG extraction pipeline and building evaluation dataset for each evaluation report implies to set up a dedicated team and infrastructure.

Given the size of linked investment, pooling expertise (sharing scripts) and accessing capacity (server infrastructure) around this objective and across the UN system could make sense.